(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{448:function(e,t,a){"use strict";a.r(t);var n=a(66),o=Object(n.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"hello-world"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#hello-world"}},[e._v("#")]),e._v(" Hello, world!")]),e._v(" "),a("p",[e._v("Note: This section is a continuation of "),a("RouterLink",{attrs:{to:"/tutorial/the-basics/"}},[e._v("'The Basics'")]),e._v(". If you have not read it yet we recommend you take a look at it before continuing!")],1),e._v(" "),a("hr"),e._v(" "),a("p",[e._v("Within "),a("RouterLink",{attrs:{to:"/tutorial/the-basics/"}},[e._v("'The Basics'")]),e._v(" we mentioned how "),a("code",[e._v('"Hello, world!"')]),e._v(" is quite an advanced concept for Huff. The reason being that we have to an understanding of how string's are encoded in the EVM.")],1),e._v(" "),a("h2",{attrs:{id:"primer-abi-encoding"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#primer-abi-encoding"}},[e._v("#")]),e._v(" Primer: ABI Encoding")]),e._v(" "),a("p",[e._v("As strings are dynamic types it is not as simple as returning the UTF-8 values for "),a("code",[e._v('"Hello, world!"')]),e._v(" ("),a("code",[e._v("0x48656c6c6f2c20776f726c6421")]),e._v("). In the ABI standard, dynamic types are encoded in 3 parts.")]),e._v(" "),a("ol",[a("li",[e._v("The offset of the dynamic data. (A pointer to the start of the dynamic data (uint256))")]),e._v(" "),a("li",[e._v("The length of the dynamic data. (uint256)")]),e._v(" "),a("li",[e._v("The values of the dynamic data. (dynamic length)")])]),e._v(" "),a("p",[e._v("Each part will look as follows for the string "),a("code",[e._v('"Hello, world!"')]),e._v(":")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('[Byte number]   [DATA]    \n0x00            0000000000000000000000000000000000000000000000000000000000000020 // The location of the "Hello, world!" data (dynamic type).\n0x20            000000000000000000000000000000000000000000000000000000000000000d // The length of "Hello, world!" in bytes\n0x40            48656c6c6f2c20776f726c642100000000000000000000000000000000000000 // Value "Hello, world!"\n')])])]),a("p",[e._v("Encoding dynamic values takes alot of work!! In order to return "),a("code",[e._v('"Hello, world!"')]),e._v(" we must return 96 bytes!")]),e._v(" "),a("p",[e._v('You might think that we can populate the memory in sequential order starting with the location (0x00), then length (0x20), and then the value (0x40). However, this would result in the value "Hello, world!" being left padded. We would get:')]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('[Byte number]   [DATA]    \n0x00            0000000000000000000000000000000000000000000000000000000000000020 // The location of the "Hello, world!" data (dynamic type).\n0x20            000000000000000000000000000000000000000000000000000000000000000d // The length of "Hello, world!" in bytes\n0x40            0000000000000000000000000000000000000048656c6c6f2c20776f726c6421 // Wrong encoding!\n')])])]),a("p",[e._v("This is not what we need. Instead, we're going to leverage what we know about memory to produce the right result:")]),e._v(" "),a("ul",[a("li",[e._v("Memory is always expanded in 32 byte increments")]),e._v(" "),a("li",[e._v("We can store a value starting from any index")]),e._v(" "),a("li",[e._v("Values are left padded")])]),e._v(" "),a("p",[e._v("Additionaly, in this example, we know that we want to store the location starting at 0x00 and the length starting at 0x20.")]),e._v(" "),a("p",[e._v('Armed with this knowledge, we can store the value "Hello, world!" at 0x2d (starting index of length 0x20 + the length of the data in bytes 0x0d). The first 0x2d (decimal 45) bytes are set to zero as a result of memory expansion. The left padding of "Hello, world!" is stored from bytes 0x2d (decimal 45)-> 0x3f (decimal 63).')]),e._v(" "),a("p",[e._v("This means our important bytes ("),a("code",[e._v("48656c6c6f2c20776f726c6421")]),e._v(") start at 0x40. However, since memory is expanded in 32 byte increments empty memory will be expanded with zeros to byte 0x60 (decimal 96), exactly what we need!")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("[Byte number]   [DATA]    \n0x00            0000000000000000000000000000000000000000000000000000000000000000 // Empty\n0x20            0000000000000000000000000000000000000000000000000000000000000000 // Empty\n0x40            48656c6c6f2c20776f726c642100000000000000000000000000000000000000 // Correct encoding \n")])])]),a("p",[e._v('Now we have "Hello, world!" stored, we have two things left to do. Store the length of the string in 0x20, and a pointer to the start of our dynamic data 0x00! Now let\'s see what that looks like in code.')]),e._v(" "),a("h2",{attrs:{id:"implementation"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#implementation"}},[e._v("#")]),e._v(" Implementation")]),e._v(" "),a("p",[e._v("The following "),a("code",[e._v("MAIN")]),e._v(" macro steps through this encoding in a clear way (gas optimization will be left as an exercise to the reader!)")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('#define macro MAIN() = takes(0) returns(0) {\n    // Store string "Hello, world1" in memory at 0x40\n    // 0x2d is listed as mstore pads the value\n    0x48656c6c6f2c20776f726c6421        // ["Hello, world!"]\n    0x2d                                // [0x2d, "Hello, world!"]\n    mstore                              // []\n\n    // store length of string at 0x20\n    0x0d                                // [0x0d]\n    0x20                                // [0x20, 0x0d]\n    mstore                              // []\n    \n    // store dynamic offset at 0x00 (string encoding starts at 0x20)\n    0x20                                // [0x20]\n    0x00                                // [0x00, 0x20]\n    mstore                              // []\n\n    // return full 96 byte value\n    0x60                                // [0x60]\n    0x00                                // [0x00, 0x60]\n    return                              // []\n}\n')])])]),a("p",[e._v("Have a look how memory is set and what is returned interactively within the "),a("a",{attrs:{href:"https://www.evm.codes/playground?unit=Wei&codeType=Bytecode&code='6c48656c6c6f2c20776f726c6421~2dz0d~20z20~00z~~00f3'~60z52~%01z~_",target:"_blank",rel:"noopener noreferrer"}},[e._v("evm.codes playground"),a("OutboundLink")],1),e._v(" for this example.")])])}),[],!1,null,null,null);t.default=o.exports}}]);